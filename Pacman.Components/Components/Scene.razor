@inject BrowserService Service

    <div class="scene">

        @RenderFood()

        <Header @ref="@header" />
        <PacmanUnit @ref="@pacman" />

        <GhostUnit @ref="@ghost1" ColorName="red" />
        <GhostUnit @ref="@ghost2" ColorName="green" />
        <GhostUnit @ref="@ghost3" ColorName="blue" />
        <GhostUnit @ref="@ghost4" ColorName="orange" />
    </div>


@code {

    private bool crashed;
    private int amountOfFood = 100;

    private Header header;
    private PacmanUnit pacman;

    private GhostUnit ghost1;
    private GhostUnit ghost2;
    private GhostUnit ghost3;
    private GhostUnit ghost4;

    private List<GhostUnit> ghosts;
    private List<Food> foods = new List<Food>(100);

    Timer crashTimer, lookingForEatTimer;

    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        await Task.Run(() =>
        {
            ghosts = new List<GhostUnit> { ghost1, ghost2, ghost3, ghost4 };

            crashTimer = new Timer(LookForCrash, 100);
            lookingForEatTimer = new Timer(LookingForEat, 500);
        });
    }

    void KillGhosts()
    {
        for(int i = 0; i < 4; i++)
        {
            var currentGhost = ghosts[i];
            currentGhost.Kill();
        }
    }

    void LookForCrash()
    {
        var pacmanX = pacman.Coordinates.Left;
        var pacmanY = pacman.Coordinates.Top;
        var pacmanLastX = pacman.Coordinates.Left + pacman.Size;
        var pacmanLastY = pacman.Coordinates.Top + pacman.Size;

        for(var i = 0; i < 4; i++)
        {
            var currentGhost = ghosts[i];
            var currentGhostX = currentGhost.Coordinates.Left;
            var currentGhostY = currentGhost.Coordinates.Top;
            var currentGhostLastX = currentGhost.Coordinates.Left + currentGhost.Size;
            var currentGhostLastY = currentGhost.Coordinates.Top + currentGhost.Size;

            if((pacmanX >= currentGhostX && pacmanX <= currentGhostLastX) || (pacmanLastX >= currentGhostX && pacmanLastX <= currentGhostLastX))
            {
                if((pacmanY >= currentGhostY && pacmanY <= currentGhostLastY) || (pacmanLastY >= currentGhostY && pacmanLastY <= currentGhostLastY))
                {
                    this.crashed = true;
                }
            }

            if(this.crashed)
            {
                this.header.GameOver();
                crashTimer.StopTimer();
                this.KillGhosts();
                break;
            }
        }
    }

    void LookingForEat()
    {
        var pacmanX = pacman.Coordinates.Left;
        var pacmanY = pacman.Coordinates.Top;
        var pacmanLastX = pacman.Coordinates.Left + pacman.Size / 2;
        var pacmanLastY = pacman.Coordinates.Top + pacman.Size / 2;

        for(var i = 0; i < this.foods.Count; i++)
        {
        
            var currentFood = foods[i];
            var currentFoodX = currentFood.Coordinates.Left;
            var currentFoodY = currentFood.Coordinates.Top;
            var currentFoodLastX = currentFood.Coordinates.Left + currentFood.Size / 2;
            var currentFoodLastY = currentFood.Coordinates.Top + currentFood.Size / 2;

            if((pacmanX >= currentFoodX && pacmanX <= currentFoodLastX) || (pacmanLastX >= currentFoodX && pacmanLastX <= currentFoodLastX))
            {
                if((pacmanY >= currentFoodY && pacmanY <= currentFoodLastY) || (pacmanLastY >= currentFoodY && pacmanLastY <= currentFoodLastY))
                {
                    if(!currentFood.Hidden)
                    {
                        currentFood.Ate();
                        header.Increase();
                    }
                }
            }

            if(this.crashed)
            {
                lookingForEatTimer.StopTimer();
            }
        }
    }

    RenderFragment RenderFood()
    {
        int foodSize = 60;
        int border = 20;
        int topScoreBoard = 100;


        //this.amountOfFood = ((window.innerWidth - border - foodSize) * (window.innerHeight - border - topScoreBoard)) / (foodSize * foodSize);
        this.amountOfFood = ((500 - border - foodSize) * (500 - border - topScoreBoard)) / (foodSize * foodSize);
        int currentTop = 0, currentLeft = 0;

        RenderFragment result = b =>
        {

            for(var i = 0; i < this.amountOfFood; i++)
            {
            //if (currentLeft + foodSize >= window.innerWidth - border)
            if(currentLeft + foodSize >= 500 - border)
                {
                    currentTop += foodSize;
                    currentLeft = 0;
                }

            //if (currentTop + foodSize >= (window.innerHeight - border - topScoreBoard))
            if(currentTop + foodSize >= (500 - border - topScoreBoard))
                {
                    break;
                }

                Position position = new Position { Left = currentLeft, Top = currentTop };
                currentLeft = currentLeft + foodSize;

                b.OpenComponent<Food>(0);
                b.AddAttribute(2, "Coordinates", position);
                b.AddComponentReferenceCapture(1, food => { foods.Add((Food)food); });
                b.CloseComponent();
            }
        };

        return result;
    }
}
